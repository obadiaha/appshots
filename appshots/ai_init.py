#!/usr/bin/env python3
"""AI-powered config generation. BYOKeys - bring your own API key."""

import json
import os
import re
import subprocess
from pathlib import Path
from typing import Optional

import yaml


def ai_generate_config(
    project_path: str,
    output_path: str,
    provider: Optional[str] = None,
    api_key: Optional[str] = None,
    generate_swift: bool = True,
):
    """Generate appshots.yaml using AI analysis of the codebase."""
    from .ai_analyzer import AIAnalyzer
    
    project = Path(os.path.expanduser(project_path))
    if not project.exists():
        print(f"âŒ Project not found: {project}")
        return

    print(f"ðŸ” Analyzing {project.name} with AI...")
    
    # Initialize AI analyzer
    try:
        analyzer = AIAnalyzer(provider=provider, api_key=api_key)
    except ValueError as e:
        print(f"âŒ {e}")
        return

    # Get project metadata (scheme, bundle ID, runtime)
    scheme, bundle_id, runtime = _get_project_metadata(project)
    
    # Run AI analysis
    result = analyzer.analyze(str(project), generate_swift=generate_swift)
    
    # Build the full config
    screens_yaml = result["screens_yaml"]
    
    config = f"""# AppShots Configuration â€” {scheme}
# Generated by AI analysis of {project.name}
# Review and adjust before running: appshots capture

app:
  project: {project}
  scheme: {scheme}
  bundle_id: {bundle_id}

runtime: {runtime}

# App Store Connect required devices
devices:
  - name: "iPhone 16 Pro Max"
    type: "com.apple.CoreSimulator.SimDeviceType.iPhone-16-Pro-Max"
  - name: "iPhone 16 Pro"
    type: "com.apple.CoreSimulator.SimDeviceType.iPhone-16-Pro"
  - name: "iPhone SE (3rd generation)"
    type: "com.apple.CoreSimulator.SimDeviceType.iPhone-SE-3rd-generation"

# AI-detected screens (review and adjust)
{screens_yaml}

# Marketing text overlays (off by default - add your own captions per screen)
overlays:
  enabled: false
  font: "Arial Bold"
  font_size: 72
  text_color: "#FFFFFF"
  outline_color: "#000000"
  outline_width: 4
  position: "top"
  gradient_overlay: true

# Output settings
output:
  directory: "./screenshots"
  format: "png"
  organize_by: "device"
"""

    # Post-process: fix common AI mistakes
    config = _fix_config(config)

    with open(output_path, "w") as f:
        f.write(config)

    print(f"\nâœ… AI-generated config written to {output_path}")
    
    # Check for NEEDS_USER_INPUT markers
    if "NEEDS_USER_INPUT" in config:
        print(f"\nâš ï¸  Some file paths need your input. Search for 'NEEDS_USER_INPUT' in {output_path}")

    # Save Swift modifications if generated
    if result.get("swift_code"):
        swift_path = output_path.replace(".yaml", "-swift-mods.swift")
        with open(swift_path, "w") as f:
            f.write(f"// AppShots - Suggested Swift modifications for {scheme}\n")
            f.write(f"// Add these to your ContentView or App struct to support launch argument navigation\n")
            f.write(f"// Wrap in #if DEBUG to keep out of production builds\n\n")
            f.write(result["swift_code"])
        print(f"ðŸ“ Swift modifications saved to {swift_path}")
        print(f"   Review and add to your app, then run: appshots capture")
    else:
        print(f"   Review the config, then run: appshots capture")


def _fix_config(config: str) -> str:
    """Auto-fix common AI mistakes in generated configs."""
    import re
    
    # Fix Unix timestamps in defaults (e.g., ExamDate: 1770287400)
    def replace_unix_ts(m):
        key = m.group(1)
        ts = float(m.group(2))
        # Convert to ISO 8601 
        import datetime
        dt = datetime.datetime.fromtimestamp(ts, tz=datetime.timezone.utc)
        return f'{key}: "{dt.strftime("%Y-%m-%dT%H:%M:%SZ")}"  # converted from unix timestamp'
    
    config = re.sub(
        r'(\s+\w+):\s+(1[0-9]{9}(?:\.[0-9]+)?)',
        lambda m: replace_unix_ts(m) if float(m.group(2)) > 1000000000 else m.group(0),
        config
    )
    
    return config


def _get_project_metadata(project: Path):
    """Extract scheme, bundle ID, and runtime from Xcode project."""
    scheme = project.stem
    bundle_id = f"com.example.{scheme.lower()}"
    runtime = "com.apple.CoreSimulator.SimRuntime.iOS-26-1"

    # Try to get schemes
    result = subprocess.run(
        ["xcodebuild", "-project", str(project), "-list", "-json"],
        capture_output=True, text=True
    )
    if result.returncode == 0:
        try:
            info = json.loads(result.stdout)
            schemes = info.get("project", {}).get("schemes", [])
            if schemes:
                # Prefer the scheme matching the project name, skip extensions
                main_schemes = [s for s in schemes if "Extension" not in s and "Widget" not in s]
                scheme = main_schemes[0] if main_schemes else schemes[0]
        except json.JSONDecodeError:
            pass

    # Try to find bundle ID
    # Check if project IS a .xcodeproj, or find one inside the directory
    if project.suffix == ".xcodeproj":
        pbxproj = project / "project.pbxproj"
    else:
        pbxproj = project / "project.pbxproj"
        if not pbxproj.exists():
            # Look for .xcodeproj inside the directory
            xcodeprojs = list(project.glob("*.xcodeproj"))
            if xcodeprojs:
                pbxproj = xcodeprojs[0] / "project.pbxproj"
    if pbxproj.exists():
        content = pbxproj.read_text()
        # Find bundle IDs, prefer ones that aren't test/widget targets
        all_bids = re.findall(r'PRODUCT_BUNDLE_IDENTIFIER\s*=\s*"?([^";]+)"?', content)
        # Filter out variable references, test targets, widget targets
        real_bids = [b for b in all_bids if "$(" not in b 
                     and "Tests" not in b and "UITests" not in b 
                     and "Widget" not in b and "Extension" not in b]
        if real_bids:
            bundle_id = real_bids[0]
        elif all_bids and "$(" not in all_bids[0]:
            bundle_id = all_bids[0]

    # Find runtime
    result = subprocess.run(
        ["xcrun", "simctl", "list", "runtimes", "-j"],
        capture_output=True, text=True
    )
    if result.returncode == 0:
        try:
            runtimes = json.loads(result.stdout).get("runtimes", [])
            ios = [r for r in runtimes if r.get("platform") == "iOS" and r.get("isAvailable")]
            if ios:
                runtime = ios[-1]["identifier"]
        except (json.JSONDecodeError, KeyError):
            pass

    return scheme, bundle_id, runtime
